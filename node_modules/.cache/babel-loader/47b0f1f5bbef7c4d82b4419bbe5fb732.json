{"ast":null,"code":"var newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var _i = 1; _i < newlineCount; _i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[_i]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nexport default normalizeTokens;","map":{"version":3,"sources":["/Users/greypro/Documents/Dev/letter/letter-support/node_modules/prism-react-renderer/es/utils/normalizeTokens.js"],"names":["newlineRe","normalizeEmptyLines","line","length","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","i","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","_i","pop"],"mappings":"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","sourcesContent":["var newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var _i = 1; _i < newlineCount; _i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[_i]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nexport default normalizeTokens;"]},"metadata":{},"sourceType":"module"}